<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Cotadrez - Reglas Completas</title>
    <style>
        body { background-color: #1a252f; color: white; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; margin: 0; user-select: none; }
        .game-layout { display: flex; gap: 30px; align-items: flex-start; margin-top: 20px; }
        .inventory-panel { width: 190px; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 15px; border: 2px solid #34495e; min-height: 580px; }
        .list { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        #board { display: grid; grid-template-columns: repeat(10, 55px); grid-template-rows: repeat(10, 55px); border: 8px solid #34495e; background: #2c3e50; }
        .tile { width: 55px; height: 55px; display: flex; align-items: center; justify-content: center; position: relative; box-sizing: border-box; }
        .light { background-color: #f0d9b5; }
        .dark { background-color: #b58863; }
        .water { background-color: #3498db !important; }
        
        .deploy-zone { box-shadow: inset 0 0 0 4px #f1c40f; z-index: 2; }
        .valid-drop { background-color: rgba(46, 204, 113, 0.6) !important; }
        .invalid-ghost { background-color: rgba(231, 76, 60, 0.7) !important; }
        .shot-origin { outline: 4px solid #e67e22; outline-offset: -4px; z-index: 5; }
        .shot-target { outline: 4px solid #c0392b; outline-offset: -4px; z-index: 5; }
        .safe-escape { background-color: rgba(46, 204, 113, 0.5) !important; cursor: pointer; animation: pulse 1s infinite; outline: 2px solid white; }
        @keyframes pulse { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }

        .inventory-item { width: 55px; height: 55px; background: rgba(0,0,0,0.2); border-radius: 8px; position: relative; cursor: grab; display: flex; justify-content: center; align-items: center; }
        .inventory-item img { width: 85%; height: 85%; pointer-events: none; }
        .inventory-item.locked { opacity: 0.2; filter: grayscale(1); pointer-events: none; }
        .inventory-item.selectable { outline: 3px solid #f1c40f; cursor: pointer; background: rgba(241, 196, 15, 0.2); animation: pulse 1s infinite; }
        
        .badge { position: absolute; top: -5px; right: -5px; background: #e74c3c; color: white; border-radius: 50%; width: 18px; height: 18px; font-size: 10px; display: flex; justify-content: center; align-items: center; border: 1px solid white; pointer-events: none; }
        .piece-on-board { width: 90%; height: 90%; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5)); cursor: grab; position: relative; z-index: 10; transition: opacity 0.3s; }
        
        #status-msg { margin-bottom: 15px; font-size: 1.1em; color: #f1c40f; height: 70px; text-align: center; font-weight: bold; max-width: 800px; white-space: pre-wrap; }
        
        .graveyard { display: flex; flex-wrap: wrap; gap: 5px; min-height: 60px; background: rgba(0,0,0,0.3); border-radius: 8px; padding: 5px; border: 1px solid #444; }
        .graveyard img { width: 26px; height: 26px; opacity: 0.7; }
        .graveyard img.selectable { cursor: pointer; opacity: 1; outline: 2px solid #f1c40f; transform: scale(1.1); }
    </style>
</head>
<body>

    <h1>COTADREZ</h1>
    <div id="status-msg">Cargando recursos...</div>

    <div class="game-layout">
        <div class="inventory-panel" id="inv-rojo">
            <h3 style="color:#e74c3c; text-align:center;">ROJO</h3>
            <div id="list-rojo" class="list"></div>
            <div class="graveyard" id="grave-rojo"></div>
        </div>
        <div id="board"></div>
        <div class="inventory-panel" id="inv-negro">
            <h3 style="color:#bdc3c7; text-align:center;">NEGRO</h3>
            <div id="list-negro" class="list"></div>
            <div class="graveyard" id="grave-negro"></div>
        </div>
    </div>

<script>
// --- CONFIGURACIÓN ---
const CONFIG = {
    user: "mcuervo-web", repo: "Cotadrez", branch: "main",
    piezas: [
        { id: "fortaleza", archivo: "Castillo.svg", cant: 1, size: 2, ignoraAgua: true },
        { id: "montana", archivo: "Montana.svg", cant: 3, size: 1 },
        { id: "chusma", archivo: "Chusma.svg", cant: 3, size: 1 },
        { id: "lanceros", archivo: "Lanza.svg", cant: 3, size: 1 },
        { id: "arqueros", archivo: "Arco.svg", cant: 3, size: 1 },
        { id: "c_ligera", archivo: "CaballeriaL.svg", cant: 3, size: 1 },
        { id: "c_pesada", archivo: "CaballeriaP.svg", cant: 2, size: 1 },
        { id: "elefante", archivo: "Elefante.svg", cant: 2, size: 1 },
        { id: "escorpion", archivo: "Escorpion.svg", cant: 1, size: 1 },
        { id: "trabuquete", archivo: "Catapulta.svg", cant: 1, size: 1 },
        { id: "dragon", archivo: "Dragon.svg", cant: 1, size: 1, vuela: true },
        { id: "rey", archivo: "Rey.svg", cant: 1, size: 1 }
    ]
};

const waterCoords = ["1,3", "3,1", "1,6", "3,8", "6,1", "8,3", "6,8", "8,6"];
let stock = { rojo: {}, negro: {} }, mazmorra = { rojo: [], negro: [] };
let fortalezaColocada = { rojo: false, negro: false }, zonasAnillo = { rojo: [], negro: [] };
let mitadesAsignadas = { rojo: null, negro: null }, bandoQueEmpezo = null;
let turnoActual = null, faseJuego = "despliegue", gameOver = false;
let draggingPieceId = null, draggingArmy = null, draggingOriginTile = null;
let chusmasMovidasEsteTurno = 0, chusmaMovedId = null; // ID único de la pieza movida

// Variables de Estado de Asedio
let sVictim = null, sConqueror = null, sAttackers = [], sSavedPiece = null;

function init() {
    CONFIG.piezas.forEach(p => { stock.rojo[p.id] = p.cant; stock.negro[p.id] = p.cant; });
    createBoard();
    updateInventories();
    document.getElementById('status-msg').innerText = "FASE DE DESPLIEGUE\nEl primer jugador elige color y posiciona su Fortaleza.";
}

function getUrl(bando, archivo) {
    return `https://cdn.jsdelivr.net/gh/${CONFIG.user}/${CONFIG.repo}@${CONFIG.branch}/${bando==='rojo'?'Rojo':'Negro'}/${archivo}`;
}

function createBoard() {
    const b = document.getElementById('board');
    b.innerHTML = '';
    for(let r=0; r<10; r++){
        for(let c=0; c<10; c++){
            const t = document.createElement('div');
            t.className = `tile ${(r+c)%2===0?'light':'dark'}`;
            if(waterCoords.includes(`${r},${c}`)) t.classList.add('water');
            t.dataset.row = r; t.dataset.col = c;
            t.addEventListener('dragover', handleDragOver);
            t.addEventListener('drop', handleDrop);
            t.addEventListener('contextmenu', handleRemove);
            t.addEventListener('click', handleTileClick);
            b.appendChild(t);
        }
    }
}

function updateInventories() {
    ['rojo', 'negro'].forEach(army => {
        const panel = document.getElementById(`inv-${army}`);
        const list = document.getElementById(`list-${army}`);
        const grave = document.getElementById(`grave-${army}`);
        
        let visible = false;
        if (faseJuego === "despliegue") visible = (!bandoQueEmpezo || turnoActual === army);
        else if (faseJuego === "combate") visible = (turnoActual === army);
        else if (faseJuego.startsWith("asedio")) {
            if (faseJuego === "asedio_defensor_elige" && army === sVictim) visible = true;
            if (faseJuego === "asedio_atacante_rescata" && army === sConqueror) visible = true;
        }
        panel.style.visibility = visible ? "visible" : "hidden";

        list.innerHTML = '';
        CONFIG.piezas.forEach(p => {
            const n = stock[army][p.id];
            if (n <= 0) return;
            const item = document.createElement('div');
            let locked = true;
            
            if (faseJuego === "despliegue") {
                if (p.id === "fortaleza" && !fortalezaColocada[army]) locked = false;
                else if (fortalezaColocada[army] && p.id !== "fortaleza") locked = false;
            } else if (faseJuego === "combate") {
                locked = false; 
            } else if (faseJuego === "asedio_defensor_elige" && army === sVictim) {
                locked = true; 
                item.classList.add("selectable");
                item.onclick = () => selectPieceToSave(p.id);
            }

            item.className = `inventory-item ${locked ? 'locked' : ''}`;
            if (!locked && !item.classList.contains("selectable")) item.draggable = true;
            item.innerHTML = `<img src="${getUrl(army, p.archivo)}">${n>1?`<span class="badge">${n}</span>`:''}`;
            item.ondragstart = () => { draggingPieceId = p.id; draggingArmy = army; draggingOriginTile = null; };
            list.appendChild(item);
        });

        grave.innerHTML = '';
        mazmorra[army].forEach(pid => {
            const enemyColor = (army === 'rojo') ? 'negro' : 'rojo';
            const img = document.createElement('img');
            img.src = getUrl(enemyColor, CONFIG.piezas.find(x=>x.id===pid).archivo);
            if (faseJuego === "asedio_atacante_rescata" && army === sConqueror) {
                img.classList.add("selectable");
                img.onclick = () => finalizeSiege(pid);
            }
            grave.appendChild(img);
        });
    });
}

function getPieceAt(r, c) {
    if(r < 0 || r > 9 || c < 0 || c > 9) return null;
    const t = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
    return t ? t.querySelector('.piece-on-board') : null;
}

// --- VALIDACIÓN DE MOVIMIENTOS COMPLEXA ---
function isValidMove(pid, or, oc, r, c, army, targetImg) {
    const dr = Math.abs(r - or), dc = Math.abs(c - oc);
    const pData = CONFIG.piezas.find(x => x.id === pid);
    
    // Reglas básicas de terreno
    if (waterCoords.includes(`${r},${c}`) && !pData.vuela && !pData.ignoraAgua) return false;
    if (targetImg) {
        if (targetImg.dataset.pieceId === 'fortaleza') return false;
        if (targetImg.dataset.pieceId === 'montana' && pid !== "dragon") return false; // Dragón no aterriza en montaña
        if (targetImg.dataset.army === army && pid !== "lanceros") return false; // Solo lancero permuta
    }

    // Reglas Específicas
    if (pid === "chusma") {
        if (dr + dc !== 1) return false;
        // Restricción: No mover la misma chusma dos veces
        const draggedImg = document.querySelector(`[data-row="${or}"][data-col="${oc}"] img`);
        if (chusmasMovidasEsteTurno === 1 && draggedImg.dataset.groupId === chusmaMovedId) return false;
        return true;
    }
    if (pid === "lanceros") return (dr + dc === 1);
    if (pid === "rey") return (dr <= 1 && dc <= 1);
    
    if (pid === "arqueros") {
        if (dr !== dc) return false; // Solo diagonal
        if (dr === 1) return true;
        if (dr === 2) {
            // Solo si captura y camino libre
            if (!targetImg) return false; 
            const midR = (or + r)/2, midC = (oc + c)/2;
            if (getPieceAt(midR, midC)) return false;
            return true;
        }
        return false;
    }

    if (pid === "elefante") {
        if (dr + dc !== 1) return false;
        // Comprobar inmunidad del objetivo si es elefante (lógica de captura inversa)
        // Pero aquí validamos MI movimiento. El elefante mueve 1 ortogonal.
        return true;
    }

    if (pid === "c_pesada" || pid === "c_ligera") {
        const L = (pid === "c_pesada") ? [2,1] : [3,1];
        if (!((dr === L[0] && dc === L[1]) || (dr === L[1] && dc === L[0]))) return false;
        // Verificar 2 caminos posibles. Si AMBOS bloqueados, return false.
        // Camino 1: Eje R primero. Camino 2: Eje C primero.
        let path1Blocked = false, path2Blocked = false;
        
        // Función aux para verificar obstáculos en un segmento
        const checkSegment = (r1, c1, r2, c2) => {
            const sR = r2===r1 ? 0 : (r2>r1?1:-1), sC = c2===c1 ? 0 : (c2>c1?1:-1);
            let tr = r1+sR, tc = c1+sC;
            while(tr!==r2 || tc!==c2) {
                const obs = getPieceAt(tr, tc);
                if (waterCoords.includes(`${tr},${tc}`)) return true;
                if (obs) {
                    const type = obs.dataset.pieceId;
                    if (type === 'montana' || type === 'fortaleza') return true;
                    if (pid === "c_pesada" && obs.dataset.army !== army) return true; // Pesada no salta enemigos
                }
                tr += sR; tc += sC;
            }
            // Check corner (pivot)
            const pivotObs = getPieceAt(r2, c2);
            if (waterCoords.includes(`${r2},${c2}`)) return true;
            if (pivotObs && (pivotObs.dataset.pieceId==='montana'||pivotObs.dataset.pieceId==='fortaleza')) return true;
            if (pid === "c_pesada" && pivotObs && pivotObs.dataset.army !== army) return true;
            return false;
        };

        // Definir esquinas
        // Path A: Mover todo R, luego todo C. Pivote en (r, oc)
        path1Blocked = checkSegment(or, oc, r, oc) || checkSegment(r, oc, r, c);
        // Path B: Mover todo C, luego todo R. Pivote en (or, c)
        path2Blocked = checkSegment(or, oc, or, c) || checkSegment(or, c, r, c);

        return !(path1Blocked && path2Blocked);
    }

    if (pid === "trabuquete") {
        // Movimiento: 1 diag
        if (!targetImg && dr===1 && dc===1) return true; 
        // Disparo: Ortogonal
        if (targetImg && targetImg.dataset.army !== army && (dr===0 || dc===0)) {
            const sR = dr===0?0:(r>or?1:-1), sC = dc===0?0:(c>oc?1:-1);
            let tr = or+sR, tc = oc+sC;
            while(tr!==r || tc!==c) {
                const obs = getPieceAt(tr, tc);
                if (obs) {
                    if (obs.dataset.army === army) return false; // No dispara a través de aliados
                    if (obs.dataset.pieceId === 'montana' || obs.dataset.pieceId === 'fortaleza') return false;
                }
                tr+=sR; tc+=sC;
            }
            return true;
        }
        return false;
    }

    if (pid === "escorpion") {
        // Movimiento: 1 orto
        if (!targetImg && dr+dc===1) return true;
        // Disparo: Diag
        if (targetImg && targetImg.dataset.army !== army && dr===dc) {
            const sR = r>or?1:-1, sC = c>oc?1:-1;
            let tr = or+sR, tc = oc+sC;
            while(tr!==r || tc!==c) {
                const obs = getPieceAt(tr, tc);
                if (obs) {
                    // Bloqueo duro: Aliado, Montaña, Fortaleza
                    if (obs.dataset.army === army || obs.dataset.pieceId==='montana' || obs.dataset.pieceId==='fortaleza') return false;
                    // Si es enemigo, es pasable PERO cuenta para alineación. (Se valida en drop)
                }
                tr+=sR; tc+=sC;
            }
            return true;
        }
        return false;
    }

    if (pid === "dragon") {
        // Reina volante. Solo bloquea límites.
        if (dr===0 || dc===0 || dr===dc) return true;
        return false;
    }

    return false;
}

// Check para apoyo del Elefante y seguridad del Rey
function isSquareThreatened(r, c, attackerArmy) {
    let threatened = false;
    document.querySelectorAll('.piece-on-board').forEach(img => {
        if (img.dataset.army === attackerArmy && img.style.opacity !== "0") {
            const or = parseInt(img.parentElement.dataset.row), oc = parseInt(img.parentElement.dataset.col);
            // IMPORTANTE: Pasamos targetImg como null porque simulamos si *alcanza* la casilla vacía
            if (isValidMove(img.dataset.pieceId, or, oc, r, c, attackerArmy, null)) threatened = true;
        }
    });
    return threatened;
}

function handleDragOver(e) {
    e.preventDefault();
    if (!draggingPieceId || gameOver || faseJuego.startsWith("asedio")) return;
    const r = parseInt(this.dataset.row), c = parseInt(this.dataset.col);
    const p = CONFIG.piezas.find(x => x.id === draggingPieceId);
    document.querySelectorAll('.tile').forEach(t => t.classList.remove('valid-drop', 'invalid-ghost'));
    
    let valid = true;
    
    // 1. Ghosting visual
    for (let i=0; i<p.size; i++) for (let j=0; j<p.size; j++) {
        const t = document.querySelector(`[data-row="${r+i}"][data-col="${c+j}"]`);
        if (!t || t.children.length > 0 || (!p.ignoraAgua && waterCoords.includes(`${r+i},${c+j}`))) valid = false;
    }

    if (faseJuego === "despliegue") {
        let minR = !bandoQueEmpezo ? (r < 5 ? 0 : 5) : (mitadesAsignadas[draggingArmy] === 'norte' ? 0 : 5);
        let maxR = !bandoQueEmpezo ? (r < 5 ? 4 : 9) : (mitadesAsignadas[draggingArmy] === 'norte' ? 4 : 9);
        for (let i = 0; i < p.size; i++) for (let j = 0; j < p.size; j++) {
            const tr = r+i, tc = c+j;
            if (p.id === "fortaleza" && (tr <= minR || tr >= maxR || tc <= 0 || tc >= 9)) valid = false;
            else if (p.id === "montana" && (tr < minR || tr > maxR)) valid = false;
            else if (p.id !== "fortaleza" && p.id !== "montana" && !zonasAnillo[draggingArmy]?.includes(`${tr},${tc}`)) valid = false;
        }
    } else {
        // COMBATE
        if (!draggingOriginTile) {
            // Reserva
            if (!zonasAnillo[draggingArmy]?.includes(`${r},${c}`)) valid = false;
            if (draggingPieceId === "rey" && isSquareThreatened(r, c, draggingArmy==='rojo'?'negro':'rojo')) valid = false;
        } else {
            // Movimiento Normal
            const or = parseInt(draggingOriginTile.dataset.row), oc = parseInt(draggingOriginTile.dataset.col);
            const target = getPieceAt(r, c);
            
            // Check básico de movimiento usando la función maestra
            if (!isValidMove(draggingPieceId, or, oc, r, c, draggingArmy, target)) valid = false;

            // Check Rey suicida
            if (draggingPieceId === "rey" && isSquareThreatened(r, c, draggingArmy==='rojo'?'negro':'rojo')) valid = false;

            // Check Elefante inmunidad (desde el punto de vista del atacante)
            if (target && target.dataset.pieceId === "elefante" && draggingPieceId !== "dragon") {
                // Necesita apoyo: ¿Hay OTRA pieza mía amenazando esa casilla?
                // Simulamos quitar temporalmente la pieza que mueve para ver si hay otra
                const myImg = draggingOriginTile.querySelector('img');
                myImg.style.display = 'none';
                const hasSupport = isSquareThreatened(r, c, draggingArmy);
                myImg.style.display = 'block';
                if (!hasSupport) valid = false;
            }
        }
    }

    // Pintar
    const cssClass = valid ? 'valid-drop' : 'invalid-ghost';
    for (let i=0; i<p.size; i++) for (let j=0; j<p.size; j++) {
        const t = document.querySelector(`[data-row="${r+i}"][data-col="${c+j}"]`);
        if (t) t.classList.add(cssClass);
    }
}

function handleDrop(e) {
    e.preventDefault();
    if (!this.classList.contains('valid-drop')) return;
    const r = parseInt(this.dataset.row), c = parseInt(this.dataset.col);
    document.querySelectorAll('.shot-origin, .shot-target').forEach(t => t.classList.remove('shot-origin', 'shot-target'));

    if (faseJuego === "despliegue") {
        const p = CONFIG.piezas.find(x => x.id === draggingPieceId);
        const gId = `g-${Date.now()}`;
        if (!bandoQueEmpezo && p.id === "fortaleza") {
            bandoQueEmpezo = draggingArmy; turnoActual = draggingArmy;
            mitadesAsignadas[draggingArmy] = (r < 5) ? 'norte' : 'sur';
            mitadesAsignadas[draggingArmy==='rojo'?'negro':'rojo'] = (r < 5) ? 'sur' : 'norte';
        }
        for (let i = 0; i < p.size; i++) for (let j = 0; j < p.size; j++) {
            document.querySelector(`[data-row="${r+i}"][data-col="${c+j}"]`).appendChild(createPieceImg(draggingArmy, draggingPieceId, gId));
        }
        if (p.id === "fortaleza") { fortalezaColocada[draggingArmy] = true; actualizarAnillo(r, c, draggingArmy); }
        stock[draggingArmy][draggingPieceId]--;
        updateInventories();
    } else {
        if (!draggingOriginTile) {
            this.appendChild(createPieceImg(draggingArmy, draggingPieceId, `g-${Date.now()}`));
            stock[draggingArmy][draggingPieceId]--;
            finalizarTurnoCombate();
        } else {
            const or = parseInt(draggingOriginTile.dataset.row), oc = parseInt(draggingOriginTile.dataset.col);
            if (r===or && c===oc) {
                // Click sobre sí mismo -> Pasar turno chusma
                if (chusmasMovidasEsteTurno > 0) finalizarTurnoCombate();
                return;
            }

            const target = getPieceAt(r, c);
            const myImg = draggingOriginTile.querySelector('img');

            // Lógica Captura/Movimiento
            let captura = false;
            
            // Permuta Lanceros
            if (target && target.dataset.army === draggingArmy && draggingPieceId === "lanceros") {
                draggingOriginTile.appendChild(target);
                this.appendChild(myImg);
            } 
            // Disparos
            else if ((draggingPieceId === "trabuquete" || draggingPieceId === "escorpion") && target && target.dataset.army !== draggingArmy) {
                draggingOriginTile.classList.add('shot-origin');
                if (draggingPieceId === "escorpion") {
                    // Escorpión: Comprobar doble impacto
                    const sR = r>or?1:-1, sC = c>oc?1:-1;
                    let tr=or+sR, tc=oc+sC;
                    let pieces = [];
                    while(tr!==r || tc!==c) { 
                        let p = getPieceAt(tr,tc); if(p && p.dataset.army!==draggingArmy) pieces.push(p); 
                        tr+=sR; tc+=sC; 
                    }
                    pieces.push(target); // El objetivo clicado es el último
                    // Si hay pieza intermedia válida, capturamos ambas
                    pieces.forEach(p => capturePiece(p));
                } else {
                    // Trabuquete: Solo destino
                    capturePiece(target);
                }
                this.classList.add('shot-target');
            }
            // Movimiento Normal
            else {
                if (target) { capturePiece(target); captura = true; }
                this.appendChild(myImg);
            }

            if (draggingPieceId === "chusma" && !captura) {
                chusmasMovidasEsteTurno++; 
                chusmaMovedId = myImg.dataset.groupId;
                if (chusmasMovidasEsteTurno >= 2) finalizarTurnoCombate();
            } else {
                finalizarTurnoCombate();
            }
        }
    }
    document.querySelectorAll('.tile').forEach(t => t.classList.remove('valid-drop', 'invalid-ghost'));
}

// --- SISTEMA DE ASEDIO ---
function checkSiege() {
    ['rojo', 'negro'].forEach(victim => {
        const attacker = victim === 'rojo' ? 'negro' : 'rojo';
        let attackers = [];
        zonasAnillo[victim].forEach(coord => {
            const [tr, tc] = coord.split(',');
            const p = getPieceAt(parseInt(tr), parseInt(tc));
            // Atacante en anillo Y NO amenazado
            if (p && p.dataset.army === attacker && !isSquareThreatened(parseInt(tr), parseInt(tc), victim)) attackers.push(p);
        });

        if (attackers.length >= 2) {
            sVictim = victim; sConqueror = attacker; sAttackers = attackers;
            if (stock[victim].rey > 0) {
                let escapes = zonasAnillo[victim].filter(coord => !getPieceAt(coord.split(',')[0], coord.split(',')[1]) && !waterCoords.includes(coord) && !isSquareThreatened(coord.split(',')[0], coord.split(',')[1], attacker));
                if (escapes.length === 0) { alert(`¡JAQUE MATE A LA FORTALEZA! Rey atrapado.`); gameOver = true; }
                else {
                    faseJuego = "asedio_rey_escapa";
                    document.getElementById('status-msg').innerText = `ASEDIO: El Rey ${victim} debe escapar. Pulsa una casilla verde.`;
                    escapes.forEach(c => document.querySelector(`[data-row="${c.split(',')[0]}"][data-col="${c.split(',')[1]}"]`).classList.add('safe-escape'));
                }
            } else {
                faseJuego = "asedio_defensor_elige";
                document.getElementById('status-msg').innerText = `ASEDIO: ${victim}, salva una pieza de tu reserva.`;
            }
            updateInventories();
        }
    });
}

function handleTileClick(e) {
    if (faseJuego === "despliegue") handleFortressClick(e);
    else if (faseJuego === "asedio_rey_escapa" && e.currentTarget.classList.contains('safe-escape')) {
        e.currentTarget.appendChild(createPieceImg(sVictim, 'rey', `g-rey-esc-${Date.now()}`));
        stock[sVictim].rey = 0;
        document.querySelectorAll('.safe-escape').forEach(t => t.classList.remove('safe-escape'));
        faseJuego = "asedio_atacante_rescata";
        document.getElementById('status-msg').innerText = `${sConqueror}, rescata un prisionero de tu color.`;
        updateInventories();
    }
}

function selectPieceToSave(pid) {
    sSavedPiece = pid; stock[sVictim][pid]--;
    faseJuego = "asedio_atacante_rescata";
    document.getElementById('status-msg').innerText = `${sConqueror}, rescata un prisionero de tu color.`;
    updateInventories();
}

function finalizeSiege(pid) {
    // Vaciar reserva defensora (salvo la salvada)
    Object.keys(stock[sVictim]).forEach(id => { for(let i=0; i<stock[sVictim][id]; i++) cementerio[sConqueror].push(id); stock[sVictim][id]=0; });
    if (sSavedPiece) stock[sVictim][sSavedPiece]++;
    
    // Rescatar pieza
    const idx = cementerio[sVictim].indexOf(pid);
    if (idx > -1) {
        cementerio[sVictim].splice(idx, 1);
        stock[sConqueror][pid]++;
    }

    // Retirar atacantes
    sAttackers.forEach(img => {
        stock[sConqueror][img.dataset.pieceId]++;
        document.querySelectorAll(`[data-group-id="${img.dataset.groupId}"]`).forEach(el => el.remove());
    });

    faseJuego = "combate"; sSavedPiece = null;
    finalizarTurnoCombate();
}

function handleFortressClick(e) {
    if (faseJuego !== "despliegue") return;
    const img = e.currentTarget.querySelector('.piece-on-board');
    if (!img || img.dataset.pieceId !== 'fortaleza' || img.dataset.army !== turnoActual) return;
    const army = img.dataset.army;
    if (stock[army].montana > 0 || zonasAnillo[army].some(coord => !getPieceAt(coord.split(',')[0], coord.split(',')[1]) && !waterCoords.includes(coord))) return alert("Despliega todo primero.");

    document.querySelectorAll('.tile').forEach(t => t.classList.remove('deploy-zone'));
    if (army === bandoQueEmpezo) {
        document.querySelectorAll(`.piece-on-board[data-army="${army}"]`).forEach(i => i.style.opacity = "0");
        turnoActual = (army === 'rojo') ? 'negro' : 'rojo';
    } else {
        faseJuego = "combate"; turnoActual = bandoQueEmpezo;
        document.querySelectorAll('.piece-on-board').forEach(i => i.style.opacity = "1");
    }
    updateInventories();
}

function createPieceImg(army, pid, gid) {
    const img = document.createElement('img');
    img.src = getUrl(army, CONFIG.piezas.find(x=>x.id===pid).archivo);
    img.className = "piece-on-board";
    img.dataset.army = army; img.dataset.pieceId = pid; img.dataset.groupId = gid;
    img.draggable = true;
    img.ondragstart = (e) => {
        if (gameOver || faseJuego.startsWith("asedio")) { e.preventDefault(); return; }
        if (faseJuego === "combate" && (img.dataset.army !== turnoActual || (chusmasMovidasEsteTurno === 1 && img.dataset.pieceId !== "chusma"))) { e.preventDefault(); return; }
        draggingPieceId = img.dataset.pieceId; draggingArmy = img.dataset.army; draggingOriginTile = img.parentElement;
    };
    return img;
}

function capturePiece(img) {
    if (img.dataset.pieceId === 'rey') { alert("Victoria: Rey capturado."); gameOver = true; }
    cementerio[draggingArmy].push(img.dataset.pieceId);
    document.querySelectorAll(`[data-group-id="${img.dataset.groupId}"]`).forEach(el => el.remove());
}

function finalizarTurnoCombate() {
    if (gameOver) return;
    checkSiege();
    if (faseJuego.startsWith("asedio")) return;
    chusmasMovidasEsteTurno = 0; chusmaMovedId = null;
    turnoActual = (turnoActual === 'rojo') ? 'negro' : 'rojo';
    document.getElementById('status-msg').innerText = `Turno del ${turnoActual.toUpperCase()}`;
    updateInventories();
}

function handleRemove(e) {
    e.preventDefault(); if (faseJuego !== "despliegue") return;
    const img = e.currentTarget.querySelector('.piece-on-board');
    if (!img) return;
    const army = img.dataset.army, pid = img.dataset.pieceId, gid = img.dataset.groupId;
    if (pid === 'fortaleza') { fortalezaColocada[army] = false; if(army === bandoQueEmpezo) { bandoQueEmpezo = null; turnoActual = null; } }
    stock[army][pid]++;
    document.querySelectorAll(`[data-group-id="${gid}"]`).forEach(el => el.remove());
    updateInventories();
}

function actualizarAnillo(r, c, army) {
    const coords = [];
    for (let i = r - 1; i <= r + 2; i++) for (let j = c - 1; j <= c + 2; j++) {
        if (!(i >= r && i <= r + 1 && j >= c && j <= c + 1) && i >= 0 && i <= 9 && j >= 0 && j < 10) {
            coords.push(`${i},${j}`);
            const t = document.querySelector(`[data-row="${i}"][data-col="${j}"]`);
            if (t && !t.classList.contains('water')) t.classList.add('deploy-zone');
        }
    }
    zonasAnillo[army] = coords;
}

init();
</script>
</body>
</html>
